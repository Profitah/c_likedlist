## 🔹 개요

![image](https://github.com/user-attachments/assets/f8a704ee-1037-4431-a7a2-6ba0d0a79a97)

내 MBTI: ISFP  
**창작의도와 의의가 있는 것**을 사랑함.  
고민한 것 : 문제의 본질과 이 문제가 **우리 삶에 어떤 통찰을 줄 수 있을까**

---

## 📌 문제 개요
- 오름차순 정렬된 연결 리스트에 새로운 값을 삽입하되,
- **중복된 값은 삽입하지 않고**,
- **삽입한 위치(index)를 반환**하는 함수 구현

---

## 🔍 연결 리스트란?
- 데이터와 포인터가 함께 저장된 **노드(Node)**들이
- **포인터로 서로 연결된 자료구조**

📌 특징:
- **배열처럼 연속된 메모리 공간이 아님**
- **필요할 때마다 메모리를 할당해 연결**
- 중간 삽입/삭제가 **포인터 조작만으로 가능**

---

## 🔍 C에서 왜 연결 리스트를 쓰나?
- 배열은 크기를 고정해야 하며, 중간 삽입/삭제가 느리지만,
  연결 리스트는
  - 포인터만 바꾸면 중간 삽입/삭제가 가능
  - 비연속적 메모리도 사용 가능

✅ C에서 유연한 메모리 제어를 위해 적합

---

## 🔍 문제의의
- 단순 삽입이 아닌
  - **배열 기반 중복 검사 + 연결 리스트 기반 삽입**
- 자료구조 간 협력 예시
- 중복 확인과 삽입 위치 계산이 **명확하게 분리**됨

---

## 🔧 핵심 로직

### 1️⃣ 중복 검사 (배열 활용)

```c
int *checkItems = malloc(sizeof(int) * size);
int i = 0;
ListNode *cur = ll->head;
while (cur) {
    checkItems[i++] = cur->item;
    cur = cur->next;
}
for (int j = 0; j < size; j++) {
    if (checkItems[j] == item) {
        free(checkItems);
        return -1; // 중복
    }
}
free(checkItems);
```

📌 리스트 값을 배열에 복사 → 빠른 중복 체크  
📌 메모리 해제 필수!

---

### 2️⃣ 삽입 위치 찾기

```c
ListNode *cur = ll->head, *prev = NULL;
int index = 0;
while (cur && cur->item < item) {
    prev = cur;
    cur = cur->next;
    index++;
}
```

📌 prev, cur로 삽입 위치 탐색  
📌 오름차순 유지

---

### 3️⃣ 노드 삽입

```c
ListNode *newNode = malloc(sizeof(ListNode));
if (!newNode) return -1; // 할당 실패
newNode->item = item;
newNode->next = cur;

if (!prev) ll->head = newNode;
else prev->next = newNode;

ll->size++;
return index;
```

📌 새 노드 연결, 리스트 크기 증가  
📌 삽입 인덱스 반환

---

## 📊 기술 요약 정리

| 항목         | 방식         |
|--------------|--------------|
| 중복 검사     | 배열 사용      |
| 삽입 수행     | 포인터 조작    |
| 시간복잡도     | O(n)          |
| 공간복잡도     | O(n) (배열)   |
| 주요 포인터   | cur, prev, newNode |
| 메모리 해제   | `free(checkItems)` 필수 |

✅ 중복 탐지 → 배열  
✅ 실제 삽입 → 포인터

---

## 💬 마무리 소감
- 이 문제는 단순 삽입 구현을 넘어서
- **자료구조 간의 조합과 응용**을 이해하게 도와줌.
- 배열과 연결 리스트의 장점을 각각 활용한 실용적 구현을 연습할 수 있는 문제
- **자료 구조 안의 질서와 흐름**, 그리고 **그 흐름의 미학**을 느낄 수 있었음
